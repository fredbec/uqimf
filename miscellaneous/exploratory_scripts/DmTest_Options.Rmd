---
title: "DM Test - Revision"
author: "Friederike Becker"
date: "2025-09-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(data.table)
library(sandwich)
library(DT)
.d <- `[`
```

*Internal discussion document - not polished*

## DM Test results

Show different results for the Diebold-Mariano panel test in R. We compare the results from test statistics $S^3$ and $\tilde{S}^3$ and additionally the effect of prewhitening for S3.

The test statistics $S^3$ and $\tilde{S}^3$ are based on Akgun et al (2024): *Equal predictive ability tests based on panel data with applications to OECD and IMF forecasts*. $S^3$ corresponds to the test statistic we've been using so far, while $\tilde{S}^3$  is also valid for small $T$ (uses the t-distribution) but assumes no serial correlation.

All results for test statistics, p-values and bandwidth are displayed with 5 decimal places.


## Code for DM - Test

This code is slightly adapted from Fabian's. It allows for different options in the NeweyWest-function and additionally calculates the test statistic needed for $\tilde{S}^3$.
```{r, dm_function}
dm_test <- function(loss1, loss2, lag = NULL, prewhite = TRUE, return_s3tilde = FALSE, df_corr = 1){
  
    #########################S3 (Fabians Code)###########################
    # make series of loss differences
    # loss1 is for model 1, loss2 is for model 2
    # smaller loss is better
    d <- loss1 - loss2
    # mean loss
    m <- mean(d)
    # variance estimated via Newey-West method
    # regression of d on intercept
    fit <- lm(d~1)
    # robust standard error
    s <- NeweyWest(fit, lag = lag, prewhite = prewhite) |> unname() |> sqrt() |> as.numeric()
    #s_var <- sqrt(sum(fit$residuals^2) / length(loss1))
    # t statistic
    # t > 0 indicates that model 2 is better
    # t < 0 indicates that model 1 is better
    t <- m/s
    # p-value (two-sided)
    p <- 2*pnorm(-abs(t))
    # lag length used by estimator
    k <- bwNeweyWest(fit, lag = lag, prewhite = prewhite)
    
    
    #########################S3-Tilde###########################
    #calculate variance estimate and t-stat for s3-tilde:
    std_var <- sum(fit$residuals^2) / (length(loss1) - df_corr)
    s_var <- sqrt(std_var / (length(loss1)))
    t_s3tilde <- m /s_var
    
    
    #########################Output###########################
    if(!return_s3tilde){
      list(t_stat = t, p_val = p, bandwidth = k, resids = fit$residuals) 
    } else {
      list(t_stat = t, p_val = p, bandwidth = k, t_s3tilde = t_s3tilde, resids = fit$residuals) 
    }
  }
```


```{r dm_code, echo=FALSE}

dm_test_highlevel <- function(lag = NULL, prewhite = TRUE, return_s3tilde = FALSE, df_corr = 1, get_acf = FALSE){
  # Diebold-Mariano test implementation, similar to function t_hac here:
  # https://github.com/FK83/forecastcalibration/blob/main/R/R_procs.R
  
  dm_dat <- vector(mode = "list", length = 24)
  
  dm_acf <- vector(mode = "list", length = 24)
  i <- 0
  
  combs_methods <- data.table::CJ(hr = c(0, 0.5, 1, 1.5),
                                  tgt = c("pcpi_pch", "ngdp_rpch"),
                                  model1 = c("IMF"),
                                  model2 = c("ar", "bvar_const", "bvar_const-direct"))
  
  for(i in 1:nrow(combs_methods)){
    curr_comb <- combs_methods[i,]
    curr_hr <- curr_comb[,"hr"] |> unname() |> unlist()
    curr_tgt <- curr_comb[,"tgt"] |> unname() |> unlist()
    curr_mod1 <-  curr_comb[,"model1"] |> unname() |> unlist()
    curr_mod2 <-  curr_comb[,"model2"] |> unname() |> unlist()
  
  
    ####SCORE EINLESEN Ã„NDERN
    #loss_mod1 <- fread(here("scores", "extcis_crps_values_ho_byyr.csv")) |>
    loss_mod1 <- fread(here("scores", "ci_scores_byyr_ho.csv")) |>
      .d(horizon == curr_hr) |>
      .d(target == curr_tgt) |>
      .d(model == curr_mod1) |>
      .d(, "interval_score") |>
      #.d(, "score") |>
      unname() |> unlist()
  
    #loss_mod2 <- fread(here("scores", "extcis_crps_values_ho_byyr.csv"))## |>
    if(curr_mod2 == "bvar_const-direct"){
      filename <- "bvar_ci_scores_byyr_ho.csv"
      curr_mod2 <- "bvar_const" #type of model (direct / not direct) is governed by file name
      curr_mod2_new <- "bvar_const-direct"
    } else {
      filename <- "ci_scores_byyr_ho.csv"
      curr_mod2_new <- "bvar_const"
    }
  
    loss_mod2 <- fread(here("scores", filename)) |>
      .d(horizon == curr_hr) |>
      .d(target == curr_tgt) |>
      .d(model == curr_mod2)|>
      .d(, "interval_score") |>
      #.d(, "score") |>
      unname() |> unlist()
  
    if(curr_mod2_new == "bvar_const-direct"){
      curr_mod2 <- curr_mod2_new
    }
  
    dm_res <- dm_test(loss1 = loss_mod1, loss2 = loss_mod2, 
                      lag = lag, prewhite = prewhite,
                      return_s3tilde = return_s3tilde, df_corr = df_corr)
  
    dm_dat[[i]] <- data.table(model1 = curr_mod1,
                              model2 = curr_mod2,
                              horizon = curr_hr,
                              target = curr_tgt,
                              tstat = dm_res$t_stat,
                              p_val = dm_res$p_val,
                              bandwidth = dm_res$bandwidth,
                              t_s3tilde = dm_res$t_s3tilde)
  
    if(get_acf){
      dm_acf[[i]] <- vector(mode = "list", length = 2)
      dm_acf[[i]][[1]] <- acf(dm_res$resids, plot = FALSE)
      plottgt <- ifelse(curr_tgt == "pcpi_pch", "Inf.", "GDP")
      dm_acf[[i]][[2]] <- paste0(plottgt,", ", curr_mod2, ", hor. ", curr_hr) 
    }
    
  }
  
  dm_dat <- rbindlist(dm_dat)
  
  if(get_acf){
    return(dm_acf)
  } else {
    return(dm_dat)
  }
}
```

## Automatic lag choice and prewhitening 
This is the default option implemented in the NeweyWest-function, and the setting we have so far been using. It is obtained by running

```{r, eval = FALSE}
NeweyWest(fit)
```

We thereby get the following results 

```{r, echo = FALSE}
dm_dat <- dm_test_highlevel()
datatable(
  dm_dat,
  options = list(
    pageLength = 20
    #columnDefs = list(list(width = '100px', targets = "_all")) # force fixed widths
  )
) |>
  formatRound(columns = c("tstat", "p_val", "bandwidth"), digits = 5)
```

With `r nrow(dm_dat |> .d(p_val < 0.05))` significant results, as before (since it's the same code that we've run so far).

```{r, echo = FALSE}
datatable(
  dm_dat |> .d(p_val < 0.05),
  options = list(
    pageLength = 20
  )
) |>
  formatRound(columns = c("tstat", "p_val", "bandwidth"), digits = 5)
```



## Automactic lag choice and no prewhitening 

Here, we calculate the variance based on the raw residuals by running
```{r, eval = FALSE}
NeweyWest(fit, prewhite = FALSE)
```


```{r, echo = FALSE}
dm_dat <- dm_test_highlevel(prewhite = FALSE)
datatable(
  dm_dat,
  options = list(
    pageLength = 20
  )
) |>
  formatRound(columns = c("tstat", "p_val", "bandwidth"), digits = 5)
```

With `r nrow(dm_dat |> .d(p_val < 0.05))` significant results. Note the warnings above, which stem from the bandwidth parameters, which are in some cases very large.

```{r, echo = FALSE}
datatable(
  dm_dat |> .d(p_val < 0.05),
  options = list(
    pageLength = 20
  )
) |>
  formatRound(columns = c("tstat", "p_val", "bandwidth"), digits = 5)
```


## S3-Tilde
Compare to results obtained by calculating the variance only using lag = 0, based on the raw residuals, with significance determined by the t-distribution:
```{r, echo = FALSE}
dm_dat <- dm_test_highlevel(return_s3tilde = TRUE, df_corr = 1)
datatable(
  dm_dat |> .d(, .SD, .SDcols = c("model1", "model2", "horizon", "target", "tstat", "t_s3tilde")),
  options = list(
    pageLength = 20
  )
) |>
  formatRound(columns = c("tstat", "t_s3tilde"), digits = 5)
```

```{r, echo = FALSE}
tsig <- dm_dat |> 
  .d(t_s3tilde > qt(0.975, 10) | t_s3tilde < -qt(0.975, 10))
```
Based on the above, we get `r nrow(tsig)` significant results:
```{r, echo = FALSE}
datatable(
  tsig,
  options = list(
    pageLength = 20
  )
) |>
  formatRound(columns = c("tstat", "t_s3tilde"), digits = 5)
```


## Sanity Check: Lag choice = 0 and no prewhitening 
Side note (more of a sanity check). If we don't do prewhitening and set lag = 0 for $S^3$  *and* we don't do the degrees of freedom correction for $\tilde{S}^3$  (i.e. divide by T and not by T-1), the two test statistics do coincide: 
```{r, eval = FALSE}
NeweyWest(fit, lag = 0, prewhite = FALSE)
```

```{r, echo = FALSE}
dm_dat <- dm_test_highlevel(lag = 0, prewhite = FALSE, return_s3tilde = TRUE, df_corr = 0)
datatable(
  dm_dat |> .d(, .SD, .SDcols = c("model1", "model2", "horizon", "target", "tstat", "t_s3tilde")),
  options = list(
    pageLength = 20
  )
) |>
  formatRound(columns = c("tstat", "t_s3tilde"), digits = 5)
```


## Additional Info: ACF curves
Here, we show the autocorrelation of the demeaned loss differentials. The header displays the respective competing model and the forecast horizon.

```{r, echo = FALSE}
dm_acf <- dm_test_highlevel(get_acf = TRUE)
#par(mfrow = c(4, 6), cex.main = 0.85)

# Plot each acf object
#for (acf_obj in dm_acf) {
#  plot(acf_obj[[1]], main = acf_obj[[2]])
#}
```


### GDP

```{r, echo = FALSE}
par(mfrow = c(3, 4), cex.main = 0.85)
for (k in c(1:3, 7:9, 13:15, 19:21)) {
  plot(dm_acf[[k]][[1]], main = dm_acf[[k]][[2]])
}
```

### Inflation

```{r, echo = FALSE}
par(mfrow = c(3, 4), cex.main = 0.85)
for (k in c(4:6, 10:12, 16:18, 22:24)) {
  plot(dm_acf[[k]][[1]], main = dm_acf[[k]][[2]])
}
```
